{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/aman/Desktop/Ethereum-Escrow/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nvar web3_1 = __importDefault(require(\"web3\"));\n\nvar events_1 = require(\"events\");\n\nvar timeout_1 = __importDefault(require(\"../util/timeout\"));\n\nvar gsn_provider_1 = require(\"@openzeppelin/gsn-provider\");\n\nvar network_1 = __importDefault(require(\"../util/network\"));\n\nvar providerName_1 = __importDefault(require(\"../util/providerName\")); // TODO: Change event to use types using conditional types\n\n\nvar Web3Context = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Web3Context, _events_1$EventEmitte);\n\n  function Web3Context(provider, options) {\n    var _this;\n\n    _classCallCheck(this, Web3Context);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Web3Context).call(this));\n    _this.connected = false;\n    _this.accounts = [];\n    _this.networkId = null;\n    _this.networkName = null;\n    var fullOptions = Object.assign({}, {\n      timeout: 3000,\n      pollInterval: 500,\n      gsn: false\n    }, options);\n    if (!provider) throw new Error('A web3 provider has to be defined');\n\n    if (fullOptions.gsn) {\n      var gsnOptions = typeof fullOptions.gsn === 'object' ? fullOptions.gsn : {\n        useGSN: true\n      };\n      provider = !gsnOptions.dev ? new gsn_provider_1.GSNProvider(provider, gsnOptions) : new gsn_provider_1.GSNDevProvider(provider, gsnOptions);\n    }\n\n    _this.providerName = providerName_1.default(provider);\n    _this.lib = new web3_1.default(provider);\n    _this.timeout = fullOptions.timeout;\n    _this.pollInterval = fullOptions.pollInterval;\n    return _this;\n  }\n\n  _createClass(Web3Context, [{\n    key: \"startPoll\",\n    value: function startPoll() {\n      if (!this.pollHandle) {\n        // TODO: polling interval should depend on kind of web3 provider\n        // We can query local providers often but doing the same for the network providers may create a lot of overhead\n        this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n      }\n    }\n  }, {\n    key: \"stopPoll\",\n    value: function stopPoll() {\n      if (this.pollHandle) {\n        clearTimeout(this.pollHandle);\n        this.pollHandle = undefined;\n      }\n    }\n  }, {\n    key: \"poll\",\n    value: function () {\n      var _poll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var networkIdName, accountsName, connectedName, networkNameName, newNetworkId, newNetworkName, newAccounts;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // TODO: Fiture out elegant way retrive property name dynamically\n                networkIdName = 'networkId';\n                accountsName = 'accounts';\n                connectedName = 'connected'; // getting deep here\n\n                networkNameName = 'networkName';\n                _context.prev = 4;\n                _context.next = 7;\n                return timeout_1.default(this.lib.eth.net.getId(), this.timeout);\n\n              case 7:\n                newNetworkId = _context.sent;\n                newNetworkName = network_1.default(newNetworkId);\n                this.updateValueAndFireEvent(newNetworkName, networkNameName);\n                this.updateValueAndFireEvent(newNetworkId, networkIdName, Web3Context.NetworkIdChangedEventName, function () {\n                  return [newNetworkName];\n                }); // get the accounts\n\n                _context.next = 13;\n                return timeout_1.default(this.lib.eth.getAccounts(), this.timeout);\n\n              case 13:\n                newAccounts = _context.sent;\n                this.updateValueAndFireEvent(newAccounts, accountsName, Web3Context.AccountsChangedEventName); // if web3 provider calls are success then we are connected\n\n                this.updateValueAndFireEvent(true, connectedName, Web3Context.ConnectionChangedEventName);\n                _context.next = 24;\n                break;\n\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](4);\n                // provider methods fail so we have to update the state and fire the events\n                this.updateValueAndFireEvent(false, connectedName, Web3Context.ConnectionChangedEventName);\n                this.updateValueAndFireEvent(null, networkIdName, Web3Context.NetworkIdChangedEventName, function () {\n                  return [null];\n                });\n                this.updateValueAndFireEvent(null, networkNameName);\n                this.updateValueAndFireEvent(null, accountsName, Web3Context.AccountsChangedEventName); // TODO: Implement throtling so we do not spam console\n                // console.log(e);\n\n              case 24:\n                _context.prev = 24;\n                this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n                return _context.finish(24);\n\n              case 27:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 18, 24, 27]]);\n      }));\n\n      function poll() {\n        return _poll.apply(this, arguments);\n      }\n\n      return poll;\n    }()\n  }, {\n    key: \"updateValueAndFireEvent\",\n    value: function updateValueAndFireEvent(newValue, property, eventName) {\n      var getArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {\n        return [];\n      };\n\n      if (!fast_deep_equal_1.default(newValue, this[property])) {\n        this[property] = newValue;\n        if (eventName) this.emit.apply(this, [eventName, this[property]].concat(_toConsumableArray(getArgs())));\n      }\n    } // request access according to the EIP\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n\n  }, {\n    key: \"requestAuth\",\n    value: function () {\n      var _requestAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.lib.currentProvider.send !== undefined)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var responseHandler = function responseHandler(error, response) {\n                    if (error || response.error) {\n                      reject(error || response.error);\n                    } else {\n                      resolve(response.result);\n                    }\n                  };\n\n                  var send = _this2.lib.currentProvider.send;\n                  send({\n                    method: 'eth_requestAccounts'\n                  }, responseHandler);\n                }));\n\n              case 4:\n                return _context2.abrupt(\"return\", Promise.reject(new Error(\"Web3 provider doesn't support send method\")));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function requestAuth() {\n        return _requestAuth.apply(this, arguments);\n      }\n\n      return requestAuth;\n    }()\n  }]);\n\n  return Web3Context;\n}(events_1.EventEmitter);\n\nWeb3Context.NetworkIdChangedEventName = 'NetworkIdChanged';\nWeb3Context.AccountsChangedEventName = 'AccountsChanged';\nWeb3Context.ConnectionChangedEventName = 'ConnectionChanged';\nexports.default = Web3Context;","map":null,"metadata":{},"sourceType":"script"}